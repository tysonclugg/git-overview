#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# SPDX-License-Identifier: GPL-2.0
"""
git-overview - List git branches with an overview of various stats
┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
Copyright © 2021 Tyson Clugg <tyson@clugg.net>

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License 2.0
as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
"""

from __future__ import annotations

import argparse
import atexit
import datetime
import functools
import hashlib
import io
import json
import logging
import logging.config
import os
import re
import shlex
import socket
import subprocess
import sys
import time
import typing

VERSION = "1.0.0"

DESCRIPTION = """
{prog} - List branches with an overview of various stats

Show branches with details to help determine branch freshness.

{prog} helps you keep up-to-date with the branch maintenance cycle
(eg: merge or rebase from mainline, push commits, merge back into mainline)
by providing a simple and coherent overview of what status each branch is in:

 • branch name and type via colors (eg: local/remote/mainline)
 • last commit hash and date
 • mainline status: commits (& merges) behind/ahead your "main" branch
 • upstream status: commits (& merges) to be pushed/pulled upstream
 • worktree status: staged/modified/untracked paths
""".strip()

START_TIME = datetime.datetime.fromtimestamp(
    logging._startTime  # noqa: protected-access
)
# match with https://github.com/git/git/blob/v2.34.1/trace2/tr2_sid.c
TS = START_TIME.strftime("%Y%m%dT%H%M%S.%fZ")
HOST = socket.gethostname()
if HOST:
    HOST = "H" + hashlib.sha1(HOST.encode("utf-8")).hexdigest()[:8]
else:
    HOST = "Localhost"
SID = f"{TS}-{HOST}-P{os.getpid():09d}"

STATUS_GONE = "gone!"
STATUS_NOT_PUSHED = "not pushed!"


CachedPropertyReturn = typing.TypeVar("CachedPropertyReturn")


class cached_property:
    def __init__(self, func: typing.Callable[[], CachedPropertyReturn]) -> None:
        self.func = func

    def __get__(self, instance, owner) -> typing.Union[cached_property, CachedPropertyReturn]:  # type: ignore
        if instance is None:
            return self
        val = self.func(instance)
        instance.__dict__[self.func.__name__] = val
        return val


@functools.lru_cache(maxsize=10)
def trace2_cfg(env: str, cfg: str, with_src: bool = False) -> str:
    try:
        src, val = env, os.environ[env]
    except KeyError:
        src, val = cfg, (
            subprocess.check_output(
                [
                    "git",
                    "config",
                    "--get",
                    "--null",
                    "--default=",
                    cfg,
                ]
            )
            .split(b"\x00", maxsplit=1)[0]
            .decode("utf-8")
        )
    return val, src if with_src else val


@functools.wraps(subprocess.check_call)
def check_call(args, *fargs, **fkwargs):
    LOGGER.debug("check_call %r", args, extra={"event": {"args": args}}, stacklevel=2)
    return subprocess.check_call(args, *fargs, **fkwargs)


@functools.wraps(subprocess.check_output)
def check_output(args, *fargs, **fkwargs):
    LOGGER.debug("check_output %r", args, extra={"event": {"args": args}}, stacklevel=2)
    return subprocess.check_output(args, *fargs, **fkwargs)


lru_check_output = functools.lru_cache()(check_output)


LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.DEBUG)


def sys_exit(arg=None):
    sys_exit.arg = arg
    sys.exit(arg)


sys_exit.arg = None


NO_COLOR = not sys.stdout.isatty()


@functools.lru_cache(maxsize=1000)
def git_config(*args):
    cmd_args = ["git", "config"] + list(args)
    LOGGER.debug(
        "git_config %r", cmd_args, extra={"event": {"args": args}}, stacklevel=2
    )
    return subprocess.check_output(cmd_args).decode("utf-8")


COLORS = []


def dump_config(**_):
    config = {
        "color": {
            "overview": "auto",
        }
    }
    for color in COLORS:
        if not color.cfg_section == "overview":
            continue
        config.setdefault(f'color "{color.cfg_section}"', {})[
            color.cfg_name
        ] = color.default

    for index, (section, data) in enumerate(config.items()):
        if index != 0:
            print()
        print(f"[{section}]")
        for key, val in data.items():
            print(f"\t{key} = {val}")


class Color:
    owner = None
    name = None

    def __init__(self, default: str):
        self.default = default
        COLORS.append(self)

    def __set_name__(self, owner, name):
        self.owner = owner
        self.name = name

    def __get__(self, instance, owner=None) -> Color:
        return self

    def __str__(self) -> str:  # noqa: invalid-str-returned
        return "" if self.no_color else self.pre

    def __call__(self, fmt: str, *args, **kwargs) -> str:
        msg = fmt.format(*args, **kwargs) if args or kwargs else fmt
        if self.no_color:
            return msg
        return f"{self.pre}{msg}{self.post}"

    def config_name(self) -> str:
        return self.owner._config_key.format(name=self.name)  # noqa: protected-access

    @cached_property
    def cfg_split(self):
        return self.config_name().split(".", 2)

    @cached_property
    def cfg_section(self):
        return self.cfg_split[1]

    @cached_property
    def cfg_name(self):
        return self.cfg_split[2]

    @cached_property
    def no_color(self) -> bool:
        return (
            git_config(
                "--get-colorbool",
                self.config_name().rsplit(".", 1)[0] or "color.ui",
                "false" if NO_COLOR else "true",
            ).strip()
            == "false"
        )

    @cached_property
    def pre(self) -> str:
        return git_config("--get-color", self.config_name(), self.default)

    @cached_property
    def post(self) -> str:
        return git_config("--get-color", "", "reset")


class Colors:
    _config_key = "color.overview.{name}"

    date = Color("magenta")
    orphan = Color("yellow")
    HEAD = Color("bold")
    branchMainline = Color("red")  # noqa: N815
    branchCurrent = Color("green")  # noqa: N815
    branchBehind = Color("red")  # noqa: N815
    branchAhead = Color("yellow")  # noqa: N815
    branchSynced = Color("green")  # noqa: N815
    branchRemote = Color("red")  # noqa: N815
    branchLocal = Color("normal")  # noqa: N815
    upstreamBranch = Color("blue")  # noqa: N815
    upstreamMismatch = Color("red")  # noqa: N815
    upstreamPush = Color("yellow")  # noqa: N815
    upstreamAhead = Color("yellow")  # noqa: N815
    upstreamBehind = Color("cyan")  # noqa: N815
    upstreamStatus = Color("yellow")  # noqa: N815
    mainlineMergesOnly = Color("green")  # noqa: N815
    mainlineMergesAhead = Color("yellow")  # noqa: N815
    mainlineMergesBehind = Color("red")  # noqa: N815
    worktree = Color("cyan")
    statusStaged = Color("white")  # noqa: N815
    statusModified = Color("white")  # noqa: N815
    statusUntracked = Color("white")  # noqa: N815
    statusClean = Color("green")  # noqa: N815
    pathStaged = Color("white")  # noqa: N815
    pathModified = Color("cyan")  # noqa: N815
    pathAdded = Color("green")  # noqa: N815
    pathDeleted = Color("red")  # noqa: N815
    pathRenamed = Color("magenta")  # noqa: N815
    pathCopied = Color("magenta")  # noqa: N815
    pathUntracked = Color("yellow")  # noqa: N815


class InteractiveColors:
    """


    See https://github.com/git/git/blob/v2.34.1/builtin/clean.c#L49-L66
    and https://github.com/git/git/blob/v2.34.1/Documentation/config/color.txt
    """

    _config_key = "color.interactive.{name}"

    error = Color("bold red")
    header = Color("bold")
    help = Color("bold red")
    plain = Color("normal")
    prompt = Color("bold blue")
    reset = Color("reset")


class FallbackOptions(dict):

    fallback_action = None

    def __missing__(self, k):
        self[k] = self.fallback_action
        return self.fallback_action

    def __contains__(self, k):
        return True


class FallbackAction(argparse.Action):
    def register(self, parser):
        if isinstance(
            parser._option_string_actions, FallbackOptions  # noqa: protected-access
        ):
            raise ValueError(
                f"FallbackAction already added: {parser._option_string_actions.fallback_action.dest!r}"  # noqa: protected-access
            )
        parser._option_string_actions = FallbackOptions(  # noqa: protected-access
            parser._option_string_actions  # noqa: protected-access
        )
        parser._option_string_actions.fallback_action = self  # noqa: protected-access
        return self

    def __call__(self, parser, namespace, values, option_string=None):
        new_values = []
        if option_string:
            new_values.append(option_string)
        if values:
            new_values.extend(values)
        if new_values:
            setattr(
                namespace,
                self.dest,
                getattr(namespace, self.dest, []) + new_values,
            )


class ChoicesPseudoAction(
    FallbackAction,
    argparse._SubParsersAction._ChoicesPseudoAction,  # noqa: protected-access
):
    pass


def git_worktrees():
    """Returns a dict of {worktreepath: (branch, objectname} for each worktree of the current repo."""
    result = {}
    buf = {}
    for line in check_output(["git", "worktree", "list", "--porcelain"]).split(b"\n"):
        if not line:
            if buf:  # and b"bare" not in buf:
                worktree = buf[b"worktree"].decode("utf-8")
                try:
                    objectname = buf[b"HEAD"].decode("utf-8")
                except KeyError:
                    objectname = ""
                try:
                    branch = buf[b"branch"].split(b"/", 2)[2]
                except KeyError:
                    try:
                        branch = buf[b"HEAD"]
                    except KeyError:
                        branch = check_output(
                            ["git", "-C", worktree, "rev-parse", "HEAD"]
                        )
                result[worktree] = branch.decode("utf-8"), objectname
            buf = {}
        else:
            key, val = (line.split(b" ", 1) + [None])[:2]
            buf[key] = val
    return result


class Repo:

    mainline_refname = None
    mainline = None

    def __init__(self, extra_fields, path=None):
        self.path = path
        self.refs = {}
        self.objects = {}
        mainline_candidates = []
        for ref in Ref.from_git(extra_fields=extra_fields, path=path, repo=self):
            if ref["symref"] and ref["refname"].endswith("/HEAD"):
                mainline_candidates.append(ref)
            self.refs[ref["refname"]] = ref
            try:
                obj = self.objects[ref["objectname"]]
            except KeyError:
                obj = self.objects[ref["objectname"]] = Object.from_ref(ref)
                obj.repo = self
        if len(mainline_candidates) > 0:
            if len(mainline_candidates) == 1:
                self.mainline = mainline_candidates[0]["objectname"]
                self.mainline_refname = mainline_candidates[0]["refname"]
            else:
                LOGGER.warning(
                    "multiple_mainline_candidates %r",
                    mainline_candidates,
                    extra={"event": {"candidates": mainline_candidates}},
                )

    @cached_property
    def is_bare_repository(self):
        try:
            return (
                lru_check_output(("git", "rev-parse", "--is-bare-repository"))
                == b"true\n"
            )
        except subprocess.CalledProcessError as err:
            return err.returncode


class Object(dict):
    repo = None
    refs = {}
    cache = {}

    @classmethod
    def from_ref(cls, ref):
        try:
            obj = cls.cache[ref["objectname"]]
        except KeyError:
            obj = cls.cache[ref["objectname"]] = cls(
                {
                    "objectname": ref["objectname"],
                    "objectname:short": ref["objectname:short"],
                }
            )
        obj.refs[ref["refname"]] = ref
        return obj

    @cached_property
    def is_orphan(self):
        return int(self["objectname"], 16) == 0

    @cached_property
    def spec(self):
        if self.is_orphan:
            return f"{self.repo.mainline or 'HEAD'}"
        return f"{self.repo.mainline or 'HEAD'}...{self['objectname']}"

    @cached_property
    def mainline_ahead_behind(self):
        out = lru_check_output(
            (
                "git",
                "rev-list",
                "--left-right",
                "--count",
                self.spec,
            ),
        ).decode("utf-8")
        mainline_behind, mainline_ahead = [
            int(num) for num in re.match(r"^(\d+)\t(\d+)$", out).groups()
        ]
        if self.is_orphan:
            return mainline_behind, mainline_ahead
        return mainline_ahead, mainline_behind

    @cached_property
    def mainline_ahead(self):
        return self.mainline_ahead_behind[0]

    @cached_property
    def mainline_behind(self):
        return self.mainline_ahead_behind[1]

    @cached_property
    def mainline_ahead_behind_nomerges(self):
        if self.mainline_ahead_behind == (0, 0):
            return 0, 0
        out = lru_check_output(
            (
                "git",
                "rev-list",
                "--no-merges",
                "--left-right",
                "--count",
                self.spec,
            ),
        ).decode("utf-8")
        mainline_behind, mainline_ahead = [
            int(num) for num in re.match(r"^(\d+)\t(\d+)$", out).groups()
        ]
        if self.is_orphan:
            return mainline_behind, mainline_ahead
        return mainline_ahead, mainline_behind

    @cached_property
    def mainline_ahead_nomerges(self):
        return self.mainline_ahead_behind_nomerges[0]

    @cached_property
    def mainline_ahead_merges(self):
        return self.mainline_ahead - self.mainline_ahead_nomerges

    @cached_property
    def mainline_behind_nomerges(self):
        return self.mainline_ahead_behind_nomerges[1]

    @cached_property
    def mainline_behind_merges(self):
        return self.mainline_behind - self.mainline_behind_nomerges


class Ref(dict):

    is_orphan = False
    repo = None

    _fields = {
        # <git-for-each-ref format>: <orphaned branch format>
        "HEAD": r"*",
        "authorname": r"",
        "authordate:iso": r"0000-00-00",
        "committerdate:short": r"0000-00-00",
        "objectname": r"{objectname}",
        "objectname:short": r"{objectname_short}",
        "symref": r"",
        "symref:lstrip=-2": r"",
        "symref:short": r"",
        "refname": r"{refname}",
        "refname:short": r"{refname_short}",
        "refname:rstrip=-2": r"{refname_rstrip}",
        "upstream": r"",
        "upstream:short": r"",
        "upstream:lstrip=2": r"",
        "upstream:lstrip=3": r"",
        "upstream:track,nobracket": r"",
        "push": r"",
        "push:short": r"",
        "push:track,nobracket": r"",
        "worktreepath": r"",
    }

    @classmethod
    def from_git(cls, mainline="HEAD", extra_fields=None, path=None, repo=None):
        fields = list(cls._fields) + (extra_fields or [])
        path_args = ["-C", path] if path else []
        for line in (
            check_output(
                [
                    "git",
                ]
                + path_args
                + [
                    "for-each-ref",
                    f"--format={'%00'.join(f'%({name})' for name in fields)}",
                ],
            )
            .decode("utf-8")
            .split("\n")
        ):
            if not line:
                break  # blank line (end of output)
            data = line.split("\0")
            extra_data = data[len(cls._fields) :]
            ref = cls(data[: len(cls._fields)], mainline, repo)
            ref.update(zip(extra_fields, extra_data))
            yield ref

    @classmethod
    def from_worktrees(cls, worktrees, repo, mainline="HEAD", extra_fields=None):
        cwd = os.getcwd()
        if repo.is_bare_repository:
            return
        for worktree, (branch, objectname) in list(worktrees.items()):
            is_orphan = False
            if check_output(
                ["git", "-C", worktree, "status", "--porcelain", "--branch"]
            ).startswith(b"## No commits yet on "):
                fmt = {
                    "refname": branch,
                    "refname_short": branch,
                    "refname_rstrip": branch,
                    "objectname": objectname,
                    "objectname_short": check_output(
                        ["git", "rev-parse", "--short", objectname]
                    )
                    .strip()
                    .decode("utf-8"),
                }
                event = [val.format(**fmt) for val in cls._fields.values()]
                LOGGER.debug("from_worktree_data %r", extra={"event": event})
                is_orphan = True
                data = [None]
            else:
                for line in (
                    check_output(
                        [
                            "git",
                            "-C",
                            worktree,
                            "--no-pager",
                            "branch",
                            "--list",
                            "--contains",
                            "HEAD",
                            f"""--format={
                                "%00".join(f"%({name})"
                                for name
                                in list(cls._fields) + (extra_fields or []))
                            }""",
                        ]
                    )
                    .decode("utf-8")
                    .split("\n")
                ):
                    if not line:
                        break  # blank line (end of output)
                    data = line.split("\0")
                else:
                    data = [None]
            if data[0] != "*":
                continue
            extra_data = data[len(cls._fields) :]
            ref = cls(data[: len(cls._fields)], mainline, repo)
            ref["HEAD"] = "*" if os.path.samefile(cwd, worktree) else " "
            ref["worktreepath"] = worktree
            ref.repo = ref.obj.repo = repo
            if is_orphan:
                ref.is_orphan = True
            ref.update(zip(extra_fields, extra_data))
            yield ref

    def __init__(self, data, mainline, repo):
        self.update(zip(self._fields, data))
        self.refname_short = self["refname:short"]
        self.mainline = mainline
        self.obj = Object.from_ref(self)
        self.repo = repo

    def __str__(self):
        return self["refname:short"]

    def __len__(self):
        return len(str(self))

    @cached_property
    def is_mainline(self):
        return self.repo.mainline_refname in {self["upstream"], self["refname"]}

    @cached_property
    def shortstat(self):
        return (
            lru_check_output(
                (
                    "git",
                    "diff",
                    "--shortstat",
                    self.obj.spec,
                ),
            )
            .decode("utf-8")
            .strip()
        )

    @cached_property
    def current(self):
        return self["HEAD"] == "*"

    @cached_property
    def remote(self):
        return (
            self["upstream:lstrip=2"].split("/", 1)[0]
            if self["upstream:lstrip=2"]
            else None
        )

    @cached_property
    def remote_branch(self):
        return self["upstream:lstrip=3"]

    @cached_property
    def upstream_ahead_behind_status(self):
        upstream = self["upstream:track,nobracket"]
        upstream_ahead = upstream_behind = 0
        status = None
        if self["refname"].startswith("refs/remotes/"):
            pass
        elif not self["upstream"] and self.repo.is_bare_repository:
            pass
        elif not self["upstream"]:
            status = STATUS_NOT_PUSHED
        for bit in upstream.split(", "):
            if bit == "gone":
                status = STATUS_GONE
                continue
            if not bit:
                continue
            val = int(bit.split()[1])
            if bit.startswith("ahead "):
                upstream_ahead = val
            elif bit.startswith("behind "):
                upstream_behind = val
        return upstream_ahead, upstream_behind, status

    @cached_property
    def upstream_ahead(self):
        return self.upstream_ahead_behind_status[0]

    @cached_property
    def upstream_behind(self):
        return self.upstream_ahead_behind_status[1]

    @cached_property
    def upstream_status(self):
        return self.upstream_ahead_behind_status[2]

    @cached_property
    def upstream_gone(self):
        return self.upstream_status == STATUS_GONE

    @cached_property
    def upstream_not_pushed(self):
        return self.upstream_status == STATUS_NOT_PUSHED

    @cached_property
    def upstream_name_mismatch(self):
        return self["refname:short"] != (
            self["upstream:lstrip=3"] or self["refname:short"]
        )

    @cached_property
    def stats(self):
        result = [
            self["objectname:short"],
            Colors.date(self["committerdate:short"]),
            Colors.orphan("orphan")
            if self.obj.is_orphan
            else (
                Colors.branchBehind("{:+6d}", -self.obj.mainline_behind_nomerges)
                if self.obj.mainline_behind_nomerges
                else Colors.branchSynced("synced")
            ),
            Colors.orphan("orphan")
            if self.obj.is_orphan
            else (
                Colors.branchAhead("{:+6d}", self.obj.mainline_ahead_nomerges)
                if self.obj.mainline_ahead_nomerges
                else Colors.branchSynced("merged")
            ),
        ]
        if self["upstream"]:
            upstream_style = (
                Colors.upstreamMismatch
                if self.upstream_name_mismatch
                else Colors.upstreamBranch
            )
            upstream = [
                upstream_style(self["upstream:short"]),
            ]
            if self["push"] != self["upstream"]:
                upstream.append(f"push: {Colors.upstreamPush(self['push:short'])}")
            if self.upstream_ahead:
                upstream.append(
                    Colors.upstreamAhead("↑{}", self.upstream_ahead),
                )
            if self.upstream_behind:
                upstream.append(
                    Colors.upstreamBehind("↓{}", self.upstream_behind),
                )
            if self.upstream_status:
                upstream.append(
                    Colors.upstreamStatus(self.upstream_status),
                )
            result.append(f"[{' '.join(upstream)}]")
        if self.obj.is_orphan:
            pass
        elif self.obj.mainline_behind and not self.obj.mainline_behind_nomerges:
            result.append(
                Colors.mainlineMergesOnly("only merge commits"),
            )
        elif self.obj.mainline_behind_merges:
            result.append(
                Colors.mainlineMergesBehind(
                    "{:+d} merge{}",
                    -self.obj.mainline_behind_merges,
                    "" if self.obj.mainline_behind_merges == 1 else "s",
                ),
            )
        if self.obj.is_orphan:
            pass
        elif self.obj.mainline_ahead and not self.obj.mainline_ahead_nomerges:
            result.append(
                Colors.mainlineMergesOnly("only merge commits"),
            )
        elif self.obj.mainline_ahead_merges:
            result.append(
                Colors.mainlineMergesAhead(
                    "{:+d} merge{}",
                    self.obj.mainline_ahead_merges,
                    "" if self.obj.mainline_ahead_merges == 1 else "s",
                ),
            )
        return result


def worktree_stats(worktree):  # noqa: too-many-locals
    stats = []
    home = os.path.expanduser("~")
    if worktree.startswith(home):
        path = f"~/{os.path.relpath(worktree, home)}"
    else:
        path = worktree
    stats.append(
        Colors.worktree(path),
    )
    status = {
        line[3:]: line[:2]
        for line in check_output(["git", "-C", worktree, "status", "--porcelain"])
        .decode("utf-8")
        .split("\n")
        if line.strip()
    }
    x_counts = {}
    y_counts = {}
    untracked = 0
    ignored = 0
    for xy in sorted(status.values()):
        if xy == "??":
            untracked += 1
        elif xy == "!!":
            ignored += 1
        else:
            x = xy[0]
            y = xy[1]
            x_counts[x] = x_counts.get(x, 0) + 1
            y_counts[y] = y_counts.get(y, 0) + 1

    sum_counts = 0
    for prefix, counts in [
        (Colors.statusStaged("staged"), x_counts),
        (Colors.statusModified("modified"), y_counts),
        (Colors.statusUntracked("untracked"), {"?": untracked}),
    ]:
        new_stats = []
        for val, fmt, style in [
            ("M", "~{}", Colors.pathModified),
            ("A", "+{}", Colors.pathAdded),
            ("D", "-{}", Colors.pathDeleted),
            ("R", "r{}", Colors.pathRenamed),
            ("C", "c{}", Colors.pathCopied),
            ("?", "{}", Colors.pathUntracked),
        ]:
            count = counts.get(val, 0)
            if count:
                sum_counts += count
                new_stats.append(
                    style(fmt, count),
                )
        if new_stats:
            stats.extend([prefix] + new_stats)
    if sum_counts == 0:
        stats.extend(["clean", Colors.statusClean("✓")])
    return stats


def git_log_cmd(ref, git_opts, **_kwargs):
    revision_range_aliases = {
        "-": "{ref}..{ref.mainline}",
        "+": "{ref.mainline}..{ref}",
        ".": "{ref.mainline}...{ref}",
    }
    if git_opts and git_opts[-1] in revision_range_aliases:
        revision_range = git_opts.pop(-1)
    else:
        revision_range = "."
    compare = revision_range_aliases.get(revision_range, revision_range_aliases["-"])
    try:
        ret = subprocess.call(["git", "log"] + git_opts + [compare.format(ref=ref)])
    except KeyboardInterrupt:
        ret = -1
    finally:
        # ensure terminal is useable if the git pager can't cleanup after itself
        if ret == 0:
            print("")
        else:
            sys.stdout.write(InteractiveColors.reset)


def git_cmd(cmd, git_opts, ref, **_kwargs):
    try:
        ret = subprocess.call(["git", cmd] + git_opts, cwd=ref["worktree"])
    except KeyboardInterrupt:
        ret = -1
    finally:
        # ensure terminal is useable if the git pager can't cleanup after itself
        if ret == 0:
            print("")
        else:
            sys.stdout.write(InteractiveColors.reset)


def branches(mainline, **kwargs):  # noqa: too-many-locals
    if check_output(["git", "log", "--all", "--max-count=1"]) == b"":
        print("No commits yet", file=sys.stderr)
        return
    index = 0
    interactive = kwargs.pop("interactive", False)
    verbose = kwargs.pop("verbose", False)
    sort_reverse = False
    sort_key = kwargs.pop("sort", "authordate:short")
    if sort_key.startswith("-"):
        sort_reverse = True
        sort_key = sort_key[1:]
    interactive_parser = argparse.ArgumentParser(prog="branches", add_help=False)
    subparsers = interactive_parser.add_subparsers()
    subparsers._parser_class._ChoicesPseudoAction = (  # noqa: protected-access
        ChoicesPseudoAction
    )

    branches_help_parser = subparsers.add_parser(
        "help", aliases=["?"], help="Show help"
    )

    def print_help(**_kwargs):
        interactive_parser.print_help()

    branches_help_parser.set_defaults(func=print_help)

    git_common_parser = argparse.ArgumentParser(add_help=False)
    git_opts = git_common_parser.add_argument(
        "git_opts",
        nargs="*",
        metavar="<git option>",
        default=[],
        help="options passed to `git`",
        action=FallbackAction,
    ).register(git_common_parser)

    for cmd, aliases, func, help_text in [
        ("add", [], git_cmd, "Add file contents to the index"),
        ("commit", [], git_cmd, "Record changes to the repository"),
        (
            "diff",
            ["d"],
            git_cmd,
            "Show changes between commits, commit and working tree, etc",
        ),
        ("log", ["l"], git_log_cmd, "Show commit logs"),
        ("merge", [], git_cmd, "Join two or more development histories together"),
        ("rebase", [], git_cmd, "Reapply commits on top of another base tip"),
        ("rm", [], git_cmd, "Remove files from the working tree and from the index"),
        ("show", [], git_cmd, "Show various types of objects"),
        ("status", ["s"], git_cmd, "Show the working tree status"),
    ]:
        cmd_parser = subparsers.add_parser(
            cmd, aliases=aliases, help=help_text, parents=[git_common_parser]
        )
        git_opts.register(cmd_parser)
        cmd_parser.set_defaults(func=func, cmd=cmd)

    def next_branch(**_kwargs):
        return index + 1

    branches_next_parser = subparsers.add_parser("next", aliases=["n"])
    branches_next_parser.set_defaults(func=next_branch)

    def prev_branch(**_kwargs):
        return index - 1

    branches_prev_parser = subparsers.add_parser("prev", aliases=["p"])
    branches_prev_parser.set_defaults(func=prev_branch)

    def delete_branch(ref, **kwargs):
        git_opts = list(kwargs.pop("git_opts", []))
        if ref["upstream"]:
            check_call(["git", "push", ref.remote, f":{ref.remote_branch}"])
        check_call(["git", "branch", "-D", branch] + list(git_opts))
        return index + 1

    branches_delete_parser = subparsers.add_parser("delete")
    git_opts.register(branches_delete_parser)
    branches_delete_parser.set_defaults(func=delete_branch)

    def _quit(**kwargs):
        raise SystemExit("Bye!")

    branches_quit_parser = subparsers.add_parser("quit", aliases=["q"])
    branches_quit_parser.set_defaults(func=_quit)

    usage = io.StringIO()
    interactive_parser.print_usage(file=usage)
    usage = usage.getvalue().split(" ", 2)[2].rsplit(" ", 1)[0].strip()

    worktrees = git_worktrees()
    repo = Repo(extra_fields=[sort_key])
    mainline = mainline or repo.mainline or "@"
    refs = {}
    for ref in repo.refs.values():
        refs.setdefault(ref["refname:rstrip=-2"], {})[ref["refname:short"]] = ref
    branches = list(refs.get("refs/heads", {}).values())
    upstreams = set(branch["upstream"] for branch in branches)
    if kwargs["all"] or kwargs["remote"]:
        branches.extend(
            ref
            for ref in refs.get("refs/remotes", {}).values()
            if ref["refname"] not in upstreams
        )

    def branches_and_remaining_worktrees():
        yield from branches
        yield from Ref.from_worktrees(worktrees, repo, extra_fields=[sort_key])

    visible_branches = []
    for ref in branches_and_remaining_worktrees():
        branch = str(ref)
        worktrees.pop(ref["worktreepath"], None)
        visible = True
        while True:  # allows use of `break` to short circuit the condition checks below
            if kwargs["current"]:
                visible = ref.current
                break
            if kwargs["current"] is False:
                visible &= not ref.current
            if kwargs["remote"]:
                visible &= ref["refname"].startswith("refs/remotes/")
            # BinaryAction options
            if kwargs["gone"] is not None:
                visible &= ref.upstream_gone == kwargs["gone"]
            if kwargs["pushed"] is not None:
                visible &= (not ref.upstream_not_pushed) == kwargs["pushed"]
            if kwargs["missing"] is not None:
                visible = (ref.upstream_status is not None) == kwargs["missing"]
            if not visible:
                break
            if kwargs["merged"] is not None:
                visible &= (ref.obj.mainline_ahead == 0) == kwargs[
                    "merged"
                ] and not ref.is_mainline
            if kwargs["synced"] is not None:
                visible &= (ref.obj.mainline_behind == 0) == kwargs[
                    "synced"
                ] and not ref.is_mainline
            if not visible:
                break
            if kwargs["worktree"] is not None:
                visible &= (ref["worktreepath"] != "") == kwargs["worktree"]
            break
        if visible:
            visible_branches.append(ref)
            if ref["worktreepath"] and not (repo.is_bare_repository):
                ref.stats.extend(worktree_stats(ref["worktreepath"]))

    visible_branches.sort(key=lambda ref: ref[sort_key])
    if not visible_branches:
        return
    if sort_reverse:
        visible_branches = visible_branches[::-1]

    branch_width = max(len(ref) for ref in visible_branches)
    while 0 <= index < len(visible_branches):
        index %= len(visible_branches)
        ref = visible_branches[index]
        branch = str(ref)
        while True:
            if kwargs["list"]:
                print(ref["refname:short"])
                index += 1
                break

            stats = ref.stats
            if kwargs["shortstat"]:
                stats.append(ref.shortstat)

            if ref.is_mainline:
                branch_style = Colors.branchMainline
            elif ref.current:
                branch_style = Colors.branchSynced
            elif ref["refname"].startswith("refs/remotes/"):
                branch_style = Colors.branchRemote
            else:
                branch_style = Colors.branchLocal
            if ref["symref:lstrip=-2"]:
                stats = [f"-> {ref['symref:lstrip=-2']}"]
            branch_info = (
                "{prefix}{branch}{stats}".format(  # noqa: consider-using-f-string
                    prefix=Colors.HEAD("* ") if ref.current else "  ",
                    branch=branch_style("{:<{}}", branch, branch_width),
                    stats="" if not stats else f" {' '.join(stats)}",
                )
            )
            print(branch_info)

            if verbose:
                if ref.is_orphan:
                    print("  (orphaned branch)")
                else:
                    check_call(
                        [
                            "git",
                            "log",
                            "-n1",
                            "--pretty=format:    %C(auto)%ci %h\n    %s",
                            branch,
                        ]
                    )

            if not interactive:
                index += 1
                break

            interactive_parser.set_defaults(
                branch=branch,
                worktree=ref["worktreepath"],
                ref=ref,
            )
            try:
                response = input(f"{InteractiveColors.prompt(usage)}: ")
            except KeyboardInterrupt:
                sys_exit("Bye!")

            tokens = shlex.split(response)

            if not tokens:
                continue  # no input

            if tokens[0] in {"+", "-", "."}:
                tokens.insert(0, "log")

            if tokens[0] in {"++", "--", ".."}:
                tokens[:1] = ["log", "--patch", tokens[0][0]]

            try:
                args, unknown_args = interactive_parser.parse_known_args(tokens)
            except SystemExit:
                continue
            if unknown_args:
                print(f"error: unrecognized arguments: {' '.join(unknown_args)}")
                continue
            print("")
            res = args.func(**vars(args))
            if res is not None:
                index = res
                break

    if worktrees:
        LOGGER.warning("unmatched_worktrees %r", sorted(worktrees))
        sys_exit(2)


def for_each_worktree(for_each_worktree, **_kwargs):
    for worktree, (branch, _) in git_worktrees().items():
        print(
            "{} {}: {}".format(  # noqa: consider-using-f-string
                Colors.branchCurrent(branch),
                Colors.worktree(worktree),
                " ".join(for_each_worktree),
            ),
        )
        env = os.environ.copy()
        env.update(
            name=branch,
            GIT_WORK_TREE=worktree,
        )
        check_call(
            for_each_worktree,
            shell=True,
            cwd=worktree,
            env=env,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
        )


def show_license(**_):
    print(__doc__)
    print(LICENSE_TEXT)


class Trace2Filter(logging.Filter):
    def filter(self, record: logging.LogRecord):
        record.usecs = round((record.created % 1) * 1000000)
        record.source = f"{record.filename}:{record.lineno}"
        if not hasattr(record, "event") and " " in record.msg:
            record.event, record.msg = record.msg.split(" ", 1)
        return True


class EventFormatter(logging.Formatter):
    @cached_property
    def brief(self):
        return trace2_cfg("GIT_TRACE2_EVENT_BRIEF", "trace2.eventBrief") in {
            "1",
            "true",
        }

    def format(self, record: logging.LogRecord):
        event = {}
        event.update(
            event=record.event,
            sid=SID,
            thread="main",
        )
        if not self.brief or record.event in {"start", "atexit"}:
            event["time"] = "{}.{}Z".format(  # noqa: consider-using-f-string
                time.strftime(
                    "%Y-%m-%dT%H:%M:%S",
                    time.gmtime(record.created),
                ),
                record.usecs,
            )
        if not self.brief:
            event["file"] = record.filename
            event["line"] = record.lineno
        event["t_abs"] = record.relativeCreated / 1000
        for key, val in getattr(record, "event", {}).items():
            event[key] = val
        return json.dumps(event, separators=(",", ":"), sort_keys=False)


def trace2_handler(env: str, cfg: str) -> typing.Union[logging.Handler, None]:
    target, src = trace2_cfg(env, cfg, with_src=True)
    if target in {"", "0", "false"}:
        # logger disabled
        return None
    if target in {"1", "true"}:
        # log to stderr
        return logging.StreamHandler()
    if target.isdigit():
        # log to file descriptor
        return logging.StreamHandler(
            stream=open(int(target), mode="a", encoding="utf-8")
        )
    if target.startswith("/"):
        # log to absolute path
        if os.path.isdir(target):
            target = f"{target.rstrip('/')}/{SID}"
        return logging.FileHandler(target, mode="a", encoding="utf-8")
    if target.startswith("af_unix:"):
        sock = trace2_sock(target)
        if sock is not None:
            return logging.StreamHandler(sock.makefile(mode="w", encoding="utf-8"))
    print(f"warning: trace2: unknown value for '{src}': {target!r}", file=sys.stderr)
    return None


def trace2_sock(target: str) -> typing.Union[socket.socket, None]:
    """
    Return a socket connected to a Unix DomainSocket, or None.

    Matches with https://git-scm.com/docs/api-trace2#_enabling_a_target
    """
    socket_type, absolute_pathname = ([None] + target.split(":", 2)[1:])[-2:]
    sock = None
    if socket_type in {None, "stream"}:
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            sock.connect(absolute_pathname)
        except socket.error:
            sock = None
    if socket_type in {None, "dgram"}:
        try:
            sock = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)
            sock.connect(absolute_pathname)
        except socket.error:
            sock = None
    return sock


def start_trace2_logging():
    """
    Attach logging handler to emulate the git Trace2 API.

    See https://git-scm.com/docs/api-trace2 for details.
    """

    # ensure all LogRecord instances have `usecs` and `source` attributes
    LOGGER.addFilter(Trace2Filter())

    normal_handler = trace2_handler("GIT_TRACE2", "trace2.normalTarget")
    if normal_handler is None:
        # always show WARNING/CRITICAL messages via stderr
        normal_brief = "1"
        normal_handler = logging.StreamHandler()
        normal_handler.setLevel(logging.WARNING)
    else:
        normal_handler.setLevel(logging.DEBUG)
        normal_brief = trace2_cfg("GIT_TRACE2_BRIEF", "trace2.normalBrief") in {
            "1",
            "true",
        }
    normal_handler.setFormatter(
        logging.Formatter(
            fmt="%(source)-33s %(event)s %(message)s"
            if normal_brief
            else "%(asctime)s.%(usecs)06d %(source)-33s %(event)s %(message)s",
            datefmt="%H:%M:%S",
        )
    )
    LOGGER.addHandler(normal_handler)

    event_handler = trace2_handler("GIT_TRACE2_EVENT", "trace2.eventTarget")
    if event_handler is not None:

        event_handler.setFormatter(
            EventFormatter(
                datefmt="%Y-%m-%dT%H:%M:%S",
            )
        )
        event_handler.setLevel(logging.DEBUG)
        LOGGER.addHandler(event_handler)

    LOGGER.info("version %s", VERSION, extra={"event": {"exe": VERSION}})
    LOGGER.info("start %s", " ".join(sys.argv))

    @atexit.register
    def _exit():
        elapsed = time.time() - START_TIME.timestamp()
        code = sys_exit.arg
        if code is None:
            code = 0
        elif not isinstance(code, int):
            code = 1
        LOGGER.info(
            "atexit elapsed:%.6f code:%d",
            elapsed,
            code,
            extra={"event": {"elapsed": elapsed, "code": code}},
            stacklevel=2,
        )


def create_parser():
    class StoreAndSetFuncAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            if values:
                setattr(namespace, self.dest, values)
                setattr(namespace, "func", self.const)

    class BinaryAction(argparse.Action):
        def __init__(self, *args, **kwargs):
            kwargs.setdefault("nargs", 0)
            super().__init__(*args, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            if option_string.startswith("--"):
                # [--foo|--not-foo|--no-foo]
                value = not (
                    option_string.startswith("--not-")
                    or option_string.startswith("--no-")
                )
            else:
                # [-f|-F]: lower case is true, upper case is false.
                value = option_string.lower() == option_string
            setattr(namespace, self.dest, value)

    parser = argparse.ArgumentParser(
        description=DESCRIPTION.format(prog=InteractiveColors.header("git-overview")),
        epilog="\n".join(__doc__.split("\n")[3:4]),
    )
    parser.formatter_class = argparse.RawTextHelpFormatter
    parser.add_argument(
        "--version",
        "-V",
        action="version",
        version=f"%(prog)s {VERSION}",
    )
    branch_selection = parser.add_argument_group(
        InteractiveColors.header("branch selection")
    )
    group = branch_selection.add_mutually_exclusive_group()
    group.add_argument(
        "--all",
        "-a",
        action="store_true",
        default=False,
        help="Show all branches, not just local",
    )
    branch_output = parser.add_argument_group(
        InteractiveColors.header("branch filtering & output")
    )
    branch_output.add_argument(
        "--list",
        "-l",
        action="store_true",
        default=False,
        help="Only print the refname of each matching branch",
    )
    branch_output.add_argument(
        "--shortstat",
        action="store_true",
        default=False,
        help="Include diff shortstat in branch output",
    )
    branch_output.add_argument(
        "--mainline",
        help="Use this ref as mainline",
    )
    branch_output.add_argument(
        "--sort",
        metavar="<key>",
        action="store",
        default="authordate:iso",
        help=f"Sort key, using keys from {InteractiveColors.header('git for-each-ref')} (default: %(default)s)",
    )
    branch_output.add_argument(
        "--current",
        "-c",
        "--not-current",
        "-C",
        action=BinaryAction,
        help="Show the current branch only (or not current branches)",
    )
    upstream_filters = branch_output.add_mutually_exclusive_group()
    upstream_filters.add_argument(
        "--remote",
        "-r",
        action="store_true",
        default=False,
        help="Show remote branches",
    )
    upstream_filters.add_argument(
        "--gone",
        "-g",
        "--not-gone",
        "-G",
        action=BinaryAction,
        help="Show gone (or not gone) upstream",
    )
    upstream_filters.add_argument(
        "--pushed",
        "-p",
        "--not-pushed",
        "-P",
        action=BinaryAction,
        help="Show pushed (or not pushed) upstream",
    )
    upstream_filters.add_argument(
        "--missing",
        "--not-missing",
        action=BinaryAction,
        help="Show upstream was never pushed or is gone",
    )
    branch_output.add_argument(
        "--merged",
        "-m",
        "--not-merged",
        "-M",
        action=BinaryAction,
        help="Show merged (or not merged) with mainline",
    )
    branch_output.add_argument(
        "--synced",
        "-s",
        "--not-synced",
        "-S",
        action=BinaryAction,
        help="Show synced (or not synced) with mainline",
    )
    branch_output.add_argument(
        "--worktree",
        "-w",
        "--not-worktree",
        "-W",
        action=BinaryAction,
        help="Show branches with (or without) worktrees",
    )
    parser.add_argument(
        "--interactive",
        "-i",
        action="store_true",
        default=False,
        help="Interactive mode (EXPERIMENTAL)",
    )
    parser.add_argument(
        "--verbose", "-v", action="store_true", default=False, help="Show more details"
    )
    parser.add_argument(
        "--license",
        dest="func",
        action="store_const",
        const=show_license,
        help="Show full license text",
    )
    parser.add_argument(
        "--dump-config",
        dest="func",
        action="store_const",
        const=dump_config,
        help="Show git-overview config defaults",
    )
    parser.add_argument(
        "--for-each-worktree",
        nargs=1,
        action=StoreAndSetFuncAction,
        const=for_each_worktree,
        metavar="COMMAND",
        help="Run a shell command against each worktree",
    )
    parser.set_defaults(func=branches)
    return parser


def main():
    start_trace2_logging()
    parser = create_parser()
    args = parser.parse_args()

    return args.func(**vars(args))


LICENSE_TEXT = """
GNU GENERAL PUBLIC LICENSE Version 2, June 1991

Copyright (C) 1989, 1991 Free Software Foundation, Inc. 51 Franklin Street,
Fifth Floor, Boston, MA 02110-1301, USA

Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.

Preamble

The licenses for most software are designed to take away your freedom to share
and change it. By contrast, the GNU General Public License is intended to
guarantee your freedom to share and change free software--to make sure the
software is free for all its users. This General Public License applies to most
of the Free Software Foundation's software and to any other program whose
authors commit to using it. (Some other Free Software Foundation software is
covered by the GNU Lesser General Public License instead.) You can apply it to
your programs, too.

When we speak of free software, we are referring to freedom, not price. Our
General Public Licenses are designed to make sure that you have the freedom to
distribute copies of free software (and charge for this service if you wish),
that you receive source code or can get it if you want it, that you can change
the software or use pieces of it in new free programs; and that you know you can
do these things.

To protect your rights, we need to make restrictions that forbid anyone to deny
you these rights or to ask you to surrender the rights. These restrictions
translate to certain responsibilities for you if you distribute copies of the
software, or if you modify it.

For example, if you distribute copies of such a program, whether gratis or for a
fee, you must give the recipients all the rights that you have. You must make
sure that they, too, receive or can get the source code. And you must show them
these terms so they know their rights.

We protect your rights with two steps: (1) copyright the software, and (2) offer
you this license which gives you legal permission to copy, distribute and/or
modify the software.

Also, for each author's protection and ours, we want to make certain that
everyone understands that there is no warranty for this free software. If the
software is modified by someone else and passed on, we want its recipients to
know that what they have is not the original, so that any problems introduced by
others will not reflect on the original authors' reputations.

Finally, any free program is threatened constantly by software patents. We wish
to avoid the danger that redistributors of a free program will individually
obtain patent licenses, in effect making the program proprietary. To prevent
this, we have made it clear that any patent must be licensed for everyone's free
use or not licensed at all.

The precise terms and conditions for copying, distribution and modification
follow.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. This License applies to any program or other work which contains a notice
   placed by the copyright holder saying it may be distributed under the terms
   of this General Public License. The "Program", below, refers to any such
   program or work, and a "work based on the Program" means either the Program
   or any derivative work under copyright law: that is to say, a work containing
   the Program or a portion of it, either verbatim or with modifications and/or
   translated into another language. (Hereinafter, translation is included
   without limitation in the term "modification".) Each licensee is addressed as
   "you". Activities other than copying, distribution and modification are not
   covered by this License; they are outside its scope. The act of running the
   Program is not restricted, and the output from the Program is covered only if
   its contents constitute a work based on the Program (independent of having
   been made by running the Program). Whether that is true depends on what the
   Program does.

1. You may copy and distribute verbatim copies of the Program's source code as
   you receive it, in any medium, provided that you conspicuously and
   appropriately publish on each copy an appropriate copyright notice and
   disclaimer of warranty; keep intact all the notices that refer to this
   License and to the absence of any warranty; and give any other recipients of
   the Program a copy of this License along with the Program. You may charge a
   fee for the physical act of transferring a copy, and you may at your option
   offer warranty protection in exchange for a fee.

2. You may modify your copy or copies of the Program or any portion of it, thus
   forming a work based on the Program, and copy and distribute such
   modifications or work under the terms of Section 1 above, provided that you
   also meet all of these conditions: a) You must cause the modified files to
   carry prominent notices stating that you changed the files and the date of
   any change. b) You must cause any work that you distribute or publish, that
   in whole or in part contains or is derived from the Program or any part
   thereof, to be licensed as a whole at no charge to all third parties under
   the terms of this License. c) If the modified program normally reads commands
   interactively when run, you must cause it, when started running for such
   interactive use in the most ordinary way, to print or display an announcement
   including an appropriate copyright notice and a notice that there is no
   warranty (or else, saying that you provide a warranty) and that users may
   redistribute the program under these conditions, and telling the user how to
   view a copy of this License. (Exception: if the Program itself is interactive
   but does not normally print such an announcement, your work based on the
   Program is not required to print an announcement.) These requirements apply
   to the modified work as a whole. If identifiable sections of that work are
   not derived from the Program, and can be reasonably considered independent
   and separate works in themselves, then this License, and its terms, do not
   apply to those sections when you distribute them as separate works. But when
   you distribute the same sections as part of a whole which is a work based on
   the Program, the distribution of the whole must be on the terms of this
   License, whose permissions for other licensees extend to the entire whole,
   and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest your
rights to work written entirely by you; rather, the intent is to exercise the
right to control the distribution of derivative or collective works based on the
Program.

In addition, mere aggregation of another work not based on the Program with the
Program (or with a work based on the Program) on a volume of a storage or
distribution medium does not bring the other work under the scope of this
License.

3. You may copy and distribute the Program (or a work based on it, under Section
   2) in object code or executable form under the terms of Sections 1 and 2
   above provided that you also do one of the following: a) Accompany it with
   the complete corresponding machine-readable source code, which must be
   distributed under the terms of Sections 1 and 2 above on a medium customarily
   used for software interchange; or, b) Accompany it with a written offer,
   valid for at least three years, to give any third party, for a charge no more
   than your cost of physically performing source distribution, a complete
   machine-readable copy of the corresponding source code, to be distributed
   under the terms of Sections 1 and 2 above on a medium customarily used for
   software interchange; or, c) Accompany it with the information you received
   as to the offer to distribute corresponding source code. (This alternative is
   allowed only for noncommercial distribution and only if you received the
   program in object code or executable form with such an offer, in accord with
   Subsection b above.) The source code for a work means the preferred form of
   the work for making modifications to it. For an executable work, complete
   source code means all the source code for all modules it contains, plus any
   associated interface definition files, plus the scripts used to control
   compilation and installation of the executable. However, as a special
   exception, the source code distributed need not include anything that is
   normally distributed (in either source or binary form) with the major
   components (compiler, kernel, and so on) of the operating system on which the
   executable runs, unless that component itself accompanies the executable.

If distribution of executable or object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the source code
from the same place counts as distribution of the source code, even though third
parties are not compelled to copy the source along with the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as
   expressly provided under this License. Any attempt otherwise to copy, modify,
   sublicense or distribute the Program is void, and will automatically
   terminate your rights under this License. However, parties who have received
   copies, or rights, from you under this License will not have their licenses
   terminated so long as such parties remain in full compliance.
5. You are not required to accept this License, since you have not signed it.
   However, nothing else grants you permission to modify or distribute the
   Program or its derivative works. These actions are prohibited by law if you
   do not accept this License. Therefore, by modifying or distributing the
   Program (or any work based on the Program), you indicate your acceptance of
   this License to do so, and all its terms and conditions for copying,
   distributing or modifying the Program or works based on it.
6. Each time you redistribute the Program (or any work based on the Program),
   the recipient automatically receives a license from the original licensor to
   copy, distribute or modify the Program subject to these terms and conditions.
   You may not impose any further restrictions on the recipients' exercise of
   the rights granted herein. You are not responsible for enforcing compliance
   by third parties to this License.
7. If, as a consequence of a court judgment or allegation of patent infringement
   or for any other reason (not limited to patent issues), conditions are
   imposed on you (whether by court order, agreement or otherwise) that
   contradict the conditions of this License, they do not excuse you from the
   conditions of this License. If you cannot distribute so as to satisfy
   simultaneously your obligations under this License and any other pertinent
   obligations, then as a consequence you may not distribute the Program at all.
   For example, if a patent license would not permit royalty-free redistribution
   of the Program by all those who receive copies directly or indirectly through
   you, then the only way you could satisfy both it and this License would be to
   refrain entirely from distribution of the Program. If any portion of this
   section is held invalid or unenforceable under any particular circumstance,
   the balance of the section is intended to apply and the section as a whole is
   intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any patents or
other property right claims or to contest validity of any such claims; this
section has the sole purpose of protecting the integrity of the free software
distribution system, which is implemented by public license practices. Many
people have made generous contributions to the wide range of software
distributed through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing to
distribute software through any other system and a licensee cannot impose that
choice.

This section is intended to make thoroughly clear what is believed to be a
consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain
   countries either by patents or by copyrighted interfaces, the original
   copyright holder who places the Program under this License may add an
   explicit geographical distribution limitation excluding those countries, so
   that distribution is permitted only in or among countries not thus excluded.
   In such case, this License incorporates the limitation as if written in the
   body of this License.
9. The Free Software Foundation may publish revised and/or new versions of the
   General Public License from time to time. Such new versions will be similar
   in spirit to the present version, but may differ in detail to address new
   problems or concerns. Each version is given a distinguishing version number.
   If the Program specifies a version number of this License which applies to it
   and "any later version", you have the option of following the terms and
   conditions either of that version or of any later version published by the
   Free Software Foundation. If the Program does not specify a version number of
   this License, you may choose any version ever published by the Free Software
   Foundation.

10. If you wish to incorporate parts of the Program into other free programs
    whose distribution conditions are different, write to the author to ask for
    permission. For software which is copyrighted by the Free Software
    Foundation, write to the Free Software Foundation; we sometimes make
    exceptions for this. Our decision will be guided by the two goals of
    preserving the free status of all derivatives of our free software and of
    promoting the sharing and reuse of software generally. NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE
    PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE
    STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
    PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
    INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
    PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
    YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL
    ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE
    THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
    GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE
    OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA
    OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
    PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
    EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGES.
""".strip()

if __name__ == "__main__":
    main()
